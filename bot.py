import logging
import os
import tempfile
import subprocess
import yt_dlp
import httpx
import requests

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes

# –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ, –≥–¥–µ –ª–µ–∂–∞—Ç ffmpeg –∏ ffprobe
ffmpeg_dir = r"D:\Programming\ffmpeg-7.1.1-essentials_build\bin"

# –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Å–∏—Å—Ç–µ–º–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é PATH (–≤—Ä–µ–º–µ–Ω–Ω–æ –¥–ª—è —Å–∫—Ä–∏–ø—Ç–∞)
os.environ["PATH"] += os.pathsep + ffmpeg_dir

# üîó –£–∫–∞–∂–∏ –∞–¥—Ä–µ—Å–∞ —Å–≤–æ–∏—Ö API (ngrok)
TRANSCRIBE_API_URL = "https://hay-brazilian-ma-bulk.trycloudflare.com/transcribe"
DIARIZATION_API_URL = "https://handbook-movement-error-king.trycloudflare.com/diarize"

logging.basicConfig(level=logging.INFO)


def split_audio(input_path, segment_time=30):
    output_dir = os.path.join(os.path.dirname(input_path), "fragments")
    os.makedirs(output_dir, exist_ok=True)
    output_pattern = os.path.join(output_dir, "fragment_%03d.mp3")

    command = [
        os.path.join(ffmpeg_dir, "ffmpeg.exe"),
        "-i", input_path,
        "-f", "segment",
        "-segment_time", str(segment_time),
        "-c", "copy",
        output_pattern
    ]
    subprocess.run(command, check=True)

    fragments = sorted([
        os.path.join(output_dir, f)
        for f in os.listdir(output_dir)
        if f.startswith("fragment_")
    ])
    return fragments


def format_diarization(diarization):
    lines = []
    for segment in diarization:
        speaker = segment["speaker"]  # —É —Ç–µ–±—è —É–∂–µ —Å–ø–∏–∫–µ—Ä—ã —Å 1 –∏–ª–∏ 0, –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å
        start = segment["start"]
        end = segment["end"]
        lines.append(f"üó£ –°–ø–∏–∫–µ—Ä {speaker}: {int(start)}‚Äì{int(end)} —Å–µ–∫")
    return "\n".join(lines)


def check_ffprobe(ffmpeg_dir):
    ffprobe_path = os.path.join(ffmpeg_dir, "ffprobe.exe")
    try:
        subprocess.run([ffprobe_path, "-version"], check=True)
        print("ffprobe –Ω–∞–π–¥–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç")
    except Exception as e:
        print("–û—à–∏–±–∫–∞ —Å ffprobe:", e)


check_ffprobe(ffmpeg_dir)


# --- send_file_to_api -----------------------------------
async def send_file_to_api(file_path: str, api_url: str):
    async with httpx.AsyncClient() as client:
        with open(file_path, "rb") as f:
            files = {"file": (os.path.basename(file_path), f, "audio/mpeg")}
            try:
                response = await client.post(api_url, files=files)
            except httpx.RequestError as e:
                return {"error": f"–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å API: {e}"}

            if response.status_code != 200:
                return {"error": f"–û—à–∏–±–∫–∞ API: {response.status_code} ‚Äî {response.text}"}

            try:
                return response.json()
            except ValueError:
                return {"error": "–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç API"}


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ –∞—É–¥–∏–æ, –≤–∏–¥–µ–æ –∏–ª–∏ —Å—Å—ã–ª–∫—É (–≤ —Ç.—á. YouTube) ‚Äî —è –≤—Å—ë —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É—é üß†")

# –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –æ–¥–Ω–æ–≥–æ —Å–ø–∏–∫–µ—Ä–∞
def merge_consecutive_segments(segments):
    if not segments:
        return []

    merged = []
    current = segments[0].copy()

    for seg in segments[1:]:
        if seg["speaker"] == current["speaker"]:
            # –æ–±—ä–µ–¥–∏–Ω—è–µ–º
            current["end"] = seg["end"]
            current["text"] += " " + seg["text"]
        else:
            # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏ –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π
            merged.append(current)
            current = seg.copy()

    merged.append(current)
    return merged


import uuid


# üìπ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Å—ã–ª–∫–∏ (–≤ —Ç.—á. YouTube)
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    url = update.message.text.strip()

    if not url.startswith("http"):
        return await update.message.reply_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –∏–ª–∏ –º–µ–¥–∏–∞-—Ñ–∞–π–ª.")

    await update.message.reply_text("üîó –°–∫–∞—á–∏–≤–∞—é –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∏–¥–µ–æ...")

    # –£–±—Ä–∞—Ç—å –≤—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç DIARIZATION_API_URL
    result = download_and_transcribe_youtube(url)

    if "error" in result:
        return await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {result['error']}")

    combined = result.get("combined", [])
    if not combined:
        return await update.message.reply_text("ü§∑ –ù–∏—á–µ–≥–æ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ.")

    full_text = ""
    for seg in combined:
        full_text += f"üó£ –°–ø–∏–∫–µ—Ä {seg['speaker']}:\n{seg['text']}\n\n"

    # –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ 4000 —Å–∏–º–≤–æ–ª–æ–≤
    for i in range(0, len(full_text), 4000):
        await update.message.reply_text(full_text[i:i + 4000])


def download_and_transcribe_youtube(url: str):
    temp_dir = tempfile.gettempdir()
    unique_id = str(uuid.uuid4())
    outtmpl = os.path.join(temp_dir, unique_id + ".%(ext)s")

    try:
        ffmpeg_dir = r"D:\Programming\ffmpeg-7.1.1-essentials_build\bin"
        ydl_opts = {
            "format": "bestaudio/best",
            "outtmpl": outtmpl,
            "ffmpeg_location": ffmpeg_dir,
            "postprocessors": [{
                "key": "FFmpegExtractAudio",
                "preferredcodec": "mp3",
                "preferredquality": "192",
            }],
            "quiet": True,
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info_dict = ydl.extract_info(url, download=True)
            audio_path = ydl.prepare_filename(info_dict)
            audio_path = os.path.splitext(audio_path)[0] + ".mp3"

        if not os.path.exists(audio_path):
            return {"error": "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è"}

        # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
        fragment_dir = os.path.join(os.path.dirname(audio_path), "fragments")
        os.makedirs(fragment_dir, exist_ok=True)
        output_pattern = os.path.join(fragment_dir, "fragment_%03d.mp3")

        # –†–∞–∑–±–∏–≤–∞–µ–º –∞—É–¥–∏–æ –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –ø–æ 30 —Å–µ–∫—É–Ω–¥
        command = [
            os.path.join(ffmpeg_dir, "ffmpeg.exe"),
            "-i", audio_path,
            "-f", "segment",
            "-segment_time", "30",
            "-c", "copy",
            output_pattern
        ]
        subprocess.run(command, check=True)

        fragments = sorted([
            os.path.join(fragment_dir, f)
            for f in os.listdir(fragment_dir)
            if f.startswith("fragment_") and f.endswith(".mp3")
        ])

        if not fragments:
            return {"error": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–¥–µ–ª–∏—Ç—å –∞—É–¥–∏–æ –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã"}

        all_segments = []

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç
        for i, fragment_path in enumerate(fragments):
            # –°–º–µ—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            time_offset = i * 30

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –Ω–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—é
            with open(fragment_path, "rb") as f:
                transcript_response = requests.post(TRANSCRIBE_API_URL, files={"file": f})
                transcript_data = transcript_response.json()

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –Ω–∞ –¥–∏–∞—Ä–∏–∑–∞—Ü–∏—é
            with open(fragment_path, "rb") as f:
                diarization_response = requests.post(DIARIZATION_API_URL, files={"file": f})
                diarization_data = diarization_response.json()

            # –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∏ –æ—à–∏–±–∫—É - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç
            if "segments" not in transcript_data or "diarization" not in diarization_data:
                logging.error(
                    f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ {i}: {transcript_data.get('error', '')} {diarization_data.get('error', '')}")
                continue

            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
            for segment in transcript_data.get("segments", []):
                segment["start"] += time_offset
                segment["end"] += time_offset

            for segment in diarization_data.get("diarization", []):
                segment["start"] += time_offset
                segment["end"] += time_offset

            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            combined = combine_transcript_with_diarization(
                transcript_data.get("segments", []),
                diarization_data.get("diarization", [])
            )
            all_segments.extend(combined)

        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã
        merged = merge_consecutive_segments(all_segments)
        return {"combined": merged}

    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ YouTube –≤–∏–¥–µ–æ")
        return {"error": str(e)}

    finally:
        # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        if os.path.exists(audio_path):
            os.remove(audio_path)
        # –£–¥–∞–ª–µ–Ω–∏–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
        fragment_dir = os.path.join(os.path.dirname(audio_path), "fragments")
        if os.path.exists(fragment_dir):
            for f in os.listdir(fragment_dir):
                os.remove(os.path.join(fragment_dir, f))
            os.rmdir(fragment_dir)



# 1. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ API —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏
async def get_transcript(file_path: str):
    async with httpx.AsyncClient() as client:
        with open(file_path, "rb") as f:
            files = {"file": (os.path.basename(file_path), f, "audio/mpeg")}
            response = await client.post(TRANSCRIBE_API_URL, files=files)

        # ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ API –≤–µ—Ä–Ω—É–ª —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
        if response.status_code != 200:
            return {"error": f"–û—à–∏–±–∫–∞ API: {response.status_code} ‚Äî {response.text}"}

        try:
            result = response.json()
        except ValueError:
            # ‚úÖ –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ API –≤–µ—Ä–Ω—É–ª –ø—É—Å—Ç–æ–π/–æ–±—Ä—ã–≤–æ—á–Ω—ã–π –æ—Ç–≤–µ—Ç
            return {"error": "–û—à–∏–±–∫–∞: –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç API"}

        return result


def combine_transcript_with_diarization(transcript_segments, diarization_segments):
    result = []
    used_segments = set()  # ‚¨ÖÔ∏è —Ö—Ä–∞–Ω–µ–Ω–∏–µ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö —Ç–µ–∫—Å—Ç–æ–≤ –ø–æ start-end

    for d in diarization_segments:
        speaker = d["speaker"]
        d_start = d["start"]
        d_end = d["end"]

        speaker_text = ""

        for t in transcript_segments:
            t_start = t["start"]
            t_end = t["end"]

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
            if t_end >= d_start and t_start <= d_end:
                key = (t_start, t_end, t["text"])

                if key not in used_segments:
                    speaker_text += t["text"].strip() + " "
                    used_segments.add(key)

        result.append({
            "speaker": speaker,
            "start": d_start,
            "end": d_end,
            "text": speaker_text.strip()
        })

    return result


def download_and_transcribe_youtube(url: str):
    temp_dir = tempfile.gettempdir()
    unique_id = str(uuid.uuid4())
    outtmpl = os.path.join(temp_dir, unique_id + ".%(ext)s")

    try:
        ffmpeg_dir = r"D:\Programming\ffmpeg-7.1.1-essentials_build\bin"
        ydl_opts = {
            "format": "bestaudio/best",
            "outtmpl": outtmpl,
            "ffmpeg_location": ffmpeg_dir,
            "postprocessors": [{
                "key": "FFmpegExtractAudio",
                "preferredcodec": "mp3",
                "preferredquality": "192",
            }],
            "quiet": True,
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info_dict = ydl.extract_info(url, download=True)
            audio_path = ydl.prepare_filename(info_dict)
            audio_path = os.path.splitext(audio_path)[0] + ".mp3"

        if not os.path.exists(audio_path):
            return {"error": "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è"}

        # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
        fragment_dir = os.path.join(os.path.dirname(audio_path), "fragments")
        os.makedirs(fragment_dir, exist_ok=True)
        output_pattern = os.path.join(fragment_dir, "fragment_%03d.mp3")

        # –†–∞–∑–±–∏–≤–∞–µ–º –∞—É–¥–∏–æ –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –ø–æ 30 —Å–µ–∫—É–Ω–¥
        command = [
            os.path.join(ffmpeg_dir, "ffmpeg.exe"),
            "-i", audio_path,
            "-f", "segment",
            "-segment_time", "30",
            "-c", "copy",
            output_pattern
        ]
        subprocess.run(command, check=True)

        fragments = sorted([
            os.path.join(fragment_dir, f)
            for f in os.listdir(fragment_dir)
            if f.startswith("fragment_") and f.endswith(".mp3")
        ])

        if not fragments:
            return {"error": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–¥–µ–ª–∏—Ç—å –∞—É–¥–∏–æ –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã"}

        all_segments = []

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç
        for i, fragment_path in enumerate(fragments):
            # –°–º–µ—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            time_offset = i * 30

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –Ω–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—é
            with open(fragment_path, "rb") as f:
                transcript_response = requests.post(TRANSCRIBE_API_URL, files={"file": f})
                transcript_data = transcript_response.json()

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –Ω–∞ –¥–∏–∞—Ä–∏–∑–∞—Ü–∏—é
            with open(fragment_path, "rb") as f:
                diarization_response = requests.post(DIARIZATION_API_URL, files={"file": f})
                diarization_data = diarization_response.json()

            # –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∏ –æ—à–∏–±–∫—É - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç
            if "segments" not in transcript_data or "diarization" not in diarization_data:
                logging.error(
                    f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ {i}: {transcript_data.get('error')} {diarization_data.get('error')}")
                continue

            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
            for segment in transcript_data.get("segments", []):
                segment["start"] += time_offset
                segment["end"] += time_offset

            for segment in diarization_data.get("diarization", []):
                segment["start"] += time_offset
                segment["end"] += time_offset

            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            combined = combine_transcript_with_diarization(
                transcript_data.get("segments", []),
                diarization_data.get("diarization", [])
            )
            all_segments.extend(combined)

        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã
        merged = merge_consecutive_segments(all_segments)
        return {"combined": merged}

    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ YouTube –≤–∏–¥–µ–æ")
        return {"error": str(e)}

    finally:
        # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        if os.path.exists(audio_path):
            os.remove(audio_path)
        # –£–¥–∞–ª–µ–Ω–∏–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
        fragment_dir = os.path.join(os.path.dirname(audio_path), "fragments")
        if os.path.exists(fragment_dir):
            for f in os.listdir(fragment_dir):
                os.remove(os.path.join(fragment_dir, f))
            os.rmdir(fragment_dir)

#üîΩ –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞-—Ñ–∞–π–ª–∞
# üîΩ –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞-—Ñ–∞–π–ª–∞
async def handle_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    file = update.message.audio or update.message.voice or update.message.video or update.message.document
    if not file:
        return await update.message.reply_text("–§–∞–π–ª –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è.")

    # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
    with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as temp:
        file_path = temp.name

    # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
    tg_file = await file.get_file()
    await tg_file.download_to_drive(file_path)

    await update.message.reply_text("üì§ –ó–∞–≥—Ä—É–∂–∞—é –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–∞–π–ª...")

    try:
        # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
        fragment_dir = os.path.join(os.path.dirname(file_path), "fragments")
        os.makedirs(fragment_dir, exist_ok=True)
        output_pattern = os.path.join(fragment_dir, "fragment_%03d.mp3")

        # –†–∞–∑–±–∏–≤–∞–µ–º –∞—É–¥–∏–æ –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –ø–æ 30 —Å–µ–∫—É–Ω–¥
        command = [
            os.path.join(ffmpeg_dir, "ffmpeg.exe"),
            "-i", file_path,
            "-f", "segment",
            "-segment_time", "30",
            "-c", "copy",
            output_pattern
        ]
        subprocess.run(command, check=True)

        fragments = sorted([
            os.path.join(fragment_dir, f)
            for f in os.listdir(fragment_dir)
            if f.startswith("fragment_") and f.endswith(".mp3")
        ])

        if not fragments:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–¥–µ–ª–∏—Ç—å –∞—É–¥–∏–æ –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã")
            return

        all_segments = []

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç
        for i, fragment_path in enumerate(fragments):
            # –°–º–µ—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            time_offset = i * 30

            # –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            transcript_data = await send_file_to_api(fragment_path, TRANSCRIBE_API_URL)
            # –ü–æ–ª—É—á–∞–µ–º –¥–∏–∞—Ä–∏–∑–∞—Ü–∏—é —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            diarization_data = await send_file_to_api(fragment_path, DIARIZATION_API_URL)

            # –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∏ –æ—à–∏–±–∫—É - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç
            if "segments" not in transcript_data or "diarization" not in diarization_data:
                logging.error(
                    f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ {i}: {transcript_data.get('error')} {diarization_data.get('error')}")
                continue

            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
            for segment in transcript_data.get("segments", []):
                segment["start"] += time_offset
                segment["end"] += time_offset

            for segment in diarization_data.get("diarization", []):
                segment["start"] += time_offset
                segment["end"] += time_offset

            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
            combined = combine_transcript_with_diarization(
                transcript_data.get("segments", []),
                diarization_data.get("diarization", [])
            )
            all_segments.extend(combined)

        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã
        merged = merge_consecutive_segments(all_segments)

        # –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–π —Ç–µ–∫—Å—Ç
        full_text = ""
        for seg in merged:
            full_text += f"üó£ –°–ø–∏–∫–µ—Ä {seg['speaker']}:\n{seg['text']}\n\n"

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–∞—Å—Ç—è–º–∏
        if full_text:
            for i in range(0, len(full_text), 4000):
                await update.message.reply_text(full_text[i:i + 4000])
        else:
            await update.message.reply_text("ü§∑ –ù–∏—á–µ–≥–æ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ.")

    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞")
        await update.message.reply_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}")

    finally:
        # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        if os.path.exists(file_path):
            os.remove(file_path)
        # –£–¥–∞–ª–µ–Ω–∏–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
        fragment_dir = os.path.join(os.path.dirname(file_path), "fragments")
        if os.path.exists(fragment_dir):
            for f in os.listdir(fragment_dir):
                os.remove(os.path.join(fragment_dir, f))
            os.rmdir(fragment_dir)


def main():
    app = ApplicationBuilder().token("7618300935:AAFnmKhqc3Bxm6edtjLcgZnIU5yUHa0h1O8").build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.AUDIO | filters.VOICE | filters.VIDEO | filters.Document.ALL, handle_file))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    app.run_polling()


if __name__ == "__main__":
    main()
